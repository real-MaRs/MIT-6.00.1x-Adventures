# MIT-6.00.1x-Adventures
MIT's Introduction to Computer Science and Programming in Python Course

# 1/31/17

Week 2 - Simple Programs

2.1 - Simple Algorithms

  2.1.1 - So Far...: Reviewed what loops and if statements are and went over a guess and check loop. Can slice strings with [start:stop:step]
          Strings are immutable(can't be changed). But strings can be redefined. For loops can loop through strings and numbers.
          ex: number - for variable in range(5:10): (5,6,7,8,9)
--> better    string - for char in s: loop through length of string s                      if char == "a" 
--> meh       string - for index in range(len(s)): loop through length of string s         if index[0] == "a"
          
          word = input("Expecting a string input")
          number = int(input("Expecting a number input")
          
          if(char in string) checks if a character is in a string.
          
# 2/1/2016          
          
  2.1.2 - Approximate Solutions: are solutions that are good enough, start with a guess and increment by a small value.
          decreasing increments = slower program, increasing epsilon = less accurate answer. Went over a guess and check algorithm and 
          saw the the difference of number of times a program loops depending on the value of incrementing.
         
  2.1.3 - Bisection Search: At each stage, cut off half the values. The program ran through a loop less than 15 times to get a really
          good answer whereas the approximate solutions took over 30,000. It takes log n time, less than linear. This algorithm should
          work on any problem that has an ordering property.

  2.1.4 - Floats and Fractions: Floats approximate real numbers and it's useful to understand how.
          Decimal Number - 302 = 3*10^2 + 0*10^1 + 2*10^0
          Binary Number - 10011 = 1*2^4 + 0*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 19
          
          Internally, computers represent numbers in binary.
          
  2.1.5 - Newton-Raphson: It is a general approximation algorithm that lets you find roots of any polynomial. It took around 4 loops to
          guess the square root or cube root of a number, less than the bisection search.
          
          Iterative Algorithms - guess and check methods build on reusing same code, using a loop to generate guesses, check, continue
                               - Generating guesses: Exhaustive enumeration
                                                     Bisection search
                                                     Newton-Raphson (for root finding)
